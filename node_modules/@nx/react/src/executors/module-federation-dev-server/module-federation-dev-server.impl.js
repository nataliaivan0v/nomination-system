"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseStaticRemotesConfig = void 0;
const devkit_1 = require("@nx/devkit");
const dev_server_impl_1 = require("@nx/webpack/src/executors/dev-server/dev-server.impl");
const file_server_impl_1 = require("@nx/web/src/executors/file-server/file-server.impl");
const module_federation_1 = require("@nx/webpack/src/utils/module-federation");
const async_iterable_1 = require("@nx/devkit/src/utils/async-iterable");
const wait_for_port_open_1 = require("@nx/web/src/utils/wait-for-port-open");
const child_process_1 = require("child_process");
const path_1 = require("path");
const fs_1 = require("fs");
function getBuildOptions(buildTarget, context) {
    const target = (0, devkit_1.parseTargetString)(buildTarget, context);
    const buildOptions = (0, devkit_1.readTargetOptions)(target, context);
    return {
        ...buildOptions,
    };
}
function startStaticRemotesFileServer(staticRemotesConfig, context, options) {
    let shouldMoveToCommonLocation = false;
    let commonOutputDirectory;
    for (const app of staticRemotesConfig.remotes) {
        const remoteBasePath = staticRemotesConfig.config[app].basePath;
        if (!commonOutputDirectory) {
            commonOutputDirectory = remoteBasePath;
        }
        else if (commonOutputDirectory !== remoteBasePath) {
            shouldMoveToCommonLocation = true;
            break;
        }
    }
    if (shouldMoveToCommonLocation) {
        commonOutputDirectory = (0, path_1.join)(devkit_1.workspaceRoot, 'tmp/static-remotes');
        for (const app of staticRemotesConfig.remotes) {
            const remoteConfig = staticRemotesConfig.config[app];
            (0, fs_1.cpSync)(remoteConfig.outputPath, (0, path_1.join)(commonOutputDirectory, remoteConfig.urlSegment), {
                force: true,
                recursive: true,
            });
        }
    }
    const staticRemotesIter = (0, file_server_impl_1.default)({
        cors: true,
        watch: false,
        staticFilePath: commonOutputDirectory,
        parallel: false,
        spa: false,
        withDeps: false,
        host: options.host,
        port: options.staticRemotesPort,
        ssl: options.ssl,
        sslCert: options.sslCert,
        sslKey: options.sslKey,
    }, context);
    return staticRemotesIter;
}
async function startDevRemotes(remotes, context) {
    const devRemoteIters = [];
    for (const app of remotes.devRemotes) {
        const remoteProjectServeTarget = context.projectGraph.nodes[app].data.targets['serve'];
        const isUsingModuleFederationDevServerExecutor = remoteProjectServeTarget.executor.includes('module-federation-dev-server');
        devRemoteIters.push(await (0, devkit_1.runExecutor)({
            project: app,
            target: 'serve',
            configuration: context.configurationName,
        }, {
            watch: true,
            ...(isUsingModuleFederationDevServerExecutor
                ? { isInitialHost: false }
                : {}),
        }, context));
    }
    return devRemoteIters;
}
async function buildStaticRemotes(staticRemotesConfig, nxBin, context, options) {
    if (!staticRemotesConfig.remotes.length) {
        return;
    }
    devkit_1.logger.info(`NX Building ${staticRemotesConfig.remotes.length} static remotes...`);
    const mappedLocationOfRemotes = {};
    for (const app of staticRemotesConfig.remotes) {
        mappedLocationOfRemotes[app] = `http${options.ssl ? 's' : ''}://${options.host}:${options.staticRemotesPort}/${staticRemotesConfig.config[app].urlSegment}`;
    }
    process.env.NX_MF_DEV_SERVER_STATIC_REMOTES = JSON.stringify(mappedLocationOfRemotes);
    await new Promise((res) => {
        const staticProcess = (0, child_process_1.fork)(nxBin, [
            'run-many',
            `--target=build`,
            `--projects=${staticRemotesConfig.remotes.join(',')}`,
            ...(context.configurationName
                ? [`--configuration=${context.configurationName}`]
                : []),
            ...(options.parallel ? [`--parallel=${options.parallel}`] : []),
        ], {
            cwd: context.root,
            stdio: ['ignore', 'pipe', 'pipe', 'ipc'],
        });
        staticProcess.stdout.on('data', (data) => {
            const ANSII_CODE_REGEX = /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
            const stdoutString = data.toString().replace(ANSII_CODE_REGEX, '');
            if (stdoutString.includes('Successfully ran target build')) {
                staticProcess.stdout.removeAllListeners('data');
                devkit_1.logger.info(`NX Built ${staticRemotesConfig.remotes.length} static remotes`);
                res();
            }
        });
        staticProcess.stderr.on('data', (data) => devkit_1.logger.info(data.toString()));
        staticProcess.on('exit', (code) => {
            if (code !== 0) {
                throw new Error(`Remote failed to start. See above for errors.`);
            }
        });
        process.on('SIGTERM', () => staticProcess.kill('SIGTERM'));
        process.on('exit', () => staticProcess.kill('SIGTERM'));
    });
}
function parseStaticRemotesConfig(staticRemotes, context) {
    if (!staticRemotes?.length) {
        return { remotes: [], config: undefined };
    }
    const config = {};
    for (const app of staticRemotes) {
        const outputPath = context.projectGraph.nodes[app].data.targets['build'].options.outputPath;
        const basePath = (0, path_1.dirname)(outputPath);
        const urlSegment = (0, path_1.basename)(outputPath);
        config[app] = { basePath, outputPath, urlSegment };
    }
    return { remotes: staticRemotes, config };
}
exports.parseStaticRemotesConfig = parseStaticRemotesConfig;
async function* moduleFederationDevServer(options, context) {
    const initialStaticRemotesPorts = options.staticRemotesPort;
    options.staticRemotesPort ??= options.port + 1;
    // Force Node to resolve to look for the nx binary that is inside node_modules
    const nxBin = require.resolve('nx/bin/nx');
    const currIter = options.static
        ? (0, file_server_impl_1.default)({
            ...options,
            parallel: false,
            withDeps: false,
            spa: false,
            cors: true,
        }, context)
        : (0, dev_server_impl_1.default)(options, context);
    const p = context.projectsConfigurations.projects[context.projectName];
    const buildOptions = getBuildOptions(options.buildTarget, context);
    if (!options.isInitialHost) {
        return yield* currIter;
    }
    const moduleFederationConfig = (0, module_federation_1.getModuleFederationConfig)(buildOptions.tsConfig, context.root, p.root, 'react');
    const remotes = (0, module_federation_1.getRemotes)(options.devRemotes, options.skipRemotes, moduleFederationConfig, {
        projectName: context.projectName,
        projectGraph: context.projectGraph,
        root: context.root,
    });
    if (remotes.devRemotes.length > 0 && !initialStaticRemotesPorts) {
        options.staticRemotesPort = options.devRemotes.reduce((portToUse, r) => {
            const remotePort = context.projectGraph.nodes[r].data.targets['serve'].options.port;
            if (remotePort >= portToUse) {
                return remotePort + 1;
            }
            else {
                return portToUse;
            }
        }, options.staticRemotesPort);
    }
    const staticRemotesConfig = parseStaticRemotesConfig(remotes.staticRemotes, context);
    await buildStaticRemotes(staticRemotesConfig, nxBin, context, options);
    const devRemoteIters = await startDevRemotes(remotes, context);
    const staticRemotesIter = remotes.staticRemotes.length > 0
        ? startStaticRemotesFileServer(staticRemotesConfig, context, options)
        : undefined;
    return yield* (0, async_iterable_1.combineAsyncIterables)(currIter, ...devRemoteIters, ...(staticRemotesIter ? [staticRemotesIter] : []), (0, async_iterable_1.createAsyncIterable)(async ({ next, done }) => {
        if (!options.isInitialHost) {
            done();
            return;
        }
        if (remotes.remotePorts.length === 0) {
            done();
            return;
        }
        try {
            const portsToWaitFor = staticRemotesIter
                ? [options.staticRemotesPort, ...remotes.remotePorts]
                : [...remotes.remotePorts];
            await Promise.all(portsToWaitFor.map((port) => (0, wait_for_port_open_1.waitForPortOpen)(port, {
                retries: 480,
                retryDelay: 2500,
                host: 'localhost',
            })));
            devkit_1.logger.info(`NX All remotes started, server ready at http://localhost:${options.port}`);
            next({ success: true, baseUrl: `http://localhost:${options.port}` });
        }
        catch {
            throw new Error(`Timed out waiting for remote to start. Check above for any errors.`);
        }
        finally {
            done();
        }
    }));
}
exports.default = moduleFederationDevServer;
