"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    viteConfigurationGenerator: function() {
        return viteConfigurationGenerator;
    },
    viteConfigurationGeneratorInternal: function() {
        return viteConfigurationGeneratorInternal;
    },
    default: function() {
        return _default;
    }
});
const _extends = require("@swc/helpers/_/_extends");
const _devkit = require("@nx/devkit");
const _js = require("@nx/js");
const _generatorutils = require("../../utils/generator-utils");
const _init = require("../init/init");
const _vitestgenerator = require("../vitest/vitest-generator");
const _ensuredependencies = require("../../utils/ensure-dependencies");
function viteConfigurationGenerator(host, schema) {
    return viteConfigurationGeneratorInternal(host, _extends._({
        addPlugin: false
    }, schema));
}
async function viteConfigurationGeneratorInternal(tree, schema) {
    var _nxJson_plugins;
    var _schema, _schema1, // Setting default to jsdom since it is the most common use case (React, Web).
    // The @nx/js:lib generator specifically sets this to node to be more generic.
    _schema2;
    const tasks = [];
    var _addPlugin;
    (_addPlugin = (_schema = schema).addPlugin) != null ? _addPlugin : _schema.addPlugin = process.env.NX_ADD_PLUGINS !== 'false';
    const projectConfig = (0, _devkit.readProjectConfiguration)(tree, schema.project);
    const { targets, root: projectRoot } = projectConfig;
    var _projectConfig_projectType;
    const projectType = (_projectConfig_projectType = projectConfig.projectType) != null ? _projectConfig_projectType : 'library';
    let buildTargetName = 'build';
    let serveTargetName = 'serve';
    let testTargetName = 'test';
    var _includeLib;
    (_includeLib = (_schema1 = schema).includeLib) != null ? _includeLib : _schema1.includeLib = projectType === 'library';
    var _testEnvironment;
    (_testEnvironment = (_schema2 = schema).testEnvironment) != null ? _testEnvironment : _schema2.testEnvironment = 'jsdom';
    /**
   * This is for when we are converting an existing project
   * to use the vite executors.
   */ let projectAlreadyHasViteTargets = {};
    if (!schema.newProject) {
        var _targets_buildTargetName_options, _targets_buildTargetName;
        const userProvidedTargetName = {
            build: schema.buildTarget,
            serve: schema.serveTarget,
            test: schema.testTarget
        };
        const { validFoundTargetName, projectContainsUnsupportedExecutor, userProvidedTargetIsUnsupported, alreadyHasNxViteTargets } = (0, _generatorutils.findExistingTargetsInProject)(targets, userProvidedTargetName);
        projectAlreadyHasViteTargets = alreadyHasNxViteTargets;
        /**
     * This means that we only found unsupported build targets in that project.
     * The only way that buildTarget is defined, means that it is supported.
     *
     * If the `unsupported` flag was false, it would mean that we did not find
     * a build target at all, so we can create a new one.
     *
     * So we only throw if we found a target, but it is unsupported.
     */ if (!validFoundTargetName.build && projectContainsUnsupportedExecutor) {
            throw new Error(`The project ${schema.project} cannot be converted to use the @nx/vite executors.`);
        }
        if (alreadyHasNxViteTargets.build && (alreadyHasNxViteTargets.serve || projectType === 'library') && alreadyHasNxViteTargets.test) {
            throw new Error(`The project ${schema.project} is already configured to use the @nx/vite executors.
        Please try a different project, or remove the existing targets 
        and re-run this generator to reset the existing Vite Configuration.
        `);
        }
        /**
     * This means that we did not find any supported executors
     * so we don't have any valid target names.
     *
     * However, the executors that we may have found are not in the
     * list of the specifically unsupported executors either.
     *
     * So, we should warn the user about it.
     */ if (!projectContainsUnsupportedExecutor && !validFoundTargetName.build && !validFoundTargetName.serve && !validFoundTargetName.test) {
            await (0, _generatorutils.handleUnknownExecutors)(schema.project);
        }
        /**
     * There is a possibility at this stage that the user has provided
     * targets with unsupported executors.
     * We keep track here of which of the targets that the user provided
     * are unsupported.
     * We do this with the `userProvidedTargetIsUnsupported` object,
     * which contains flags for each target (whether it is supported or not).
     *
     * We also keep track of the targets that we found in the project,
     * through the findExistingTargetsInProject function, which returns
     * targets for build/serve/test that use supported executors, and
     * can be converted to use the vite executors. These are the
     * kept in the validFoundTargetName object.
     */ await (0, _generatorutils.handleUnsupportedUserProvidedTargets)(userProvidedTargetIsUnsupported, userProvidedTargetName, validFoundTargetName);
        var _validFoundTargetName_build;
        /**
     * Once the user is at this stage, then they can go ahead and convert.
     */ buildTargetName = (_validFoundTargetName_build = validFoundTargetName.build) != null ? _validFoundTargetName_build : buildTargetName;
        var _validFoundTargetName_serve;
        serveTargetName = (_validFoundTargetName_serve = validFoundTargetName.serve) != null ? _validFoundTargetName_serve : serveTargetName;
        if (projectType === 'application') {
            (0, _generatorutils.moveAndEditIndexHtml)(tree, schema, buildTargetName);
        }
        (0, _generatorutils.deleteWebpackConfig)(tree, projectRoot, targets == null ? void 0 : (_targets_buildTargetName = targets[buildTargetName]) == null ? void 0 : (_targets_buildTargetName_options = _targets_buildTargetName.options) == null ? void 0 : _targets_buildTargetName_options.webpackConfig);
        (0, _generatorutils.editTsConfig)(tree, schema);
    }
    const jsInitTask = await (0, _js.initGenerator)(tree, _extends._({}, schema, {
        skipFormat: true,
        tsConfigName: projectRoot === '.' ? 'tsconfig.json' : 'tsconfig.base.json'
    }));
    tasks.push(jsInitTask);
    const initTask = await (0, _init.default)(tree, _extends._({}, schema, {
        skipFormat: true
    }));
    tasks.push(initTask);
    tasks.push((0, _ensuredependencies.ensureDependencies)(tree, schema));
    const nxJson = (0, _devkit.readNxJson)(tree);
    const hasPlugin = (_nxJson_plugins = nxJson.plugins) == null ? void 0 : _nxJson_plugins.some((p)=>typeof p === 'string' ? p === '@nx/vite/plugin' : p.plugin === '@nx/vite/plugin');
    if (!hasPlugin) {
        if (!projectAlreadyHasViteTargets.build) {
            (0, _generatorutils.addOrChangeBuildTarget)(tree, schema, buildTargetName);
        }
        if (!schema.includeLib) {
            if (!projectAlreadyHasViteTargets.serve) {
                (0, _generatorutils.addOrChangeServeTarget)(tree, schema, serveTargetName);
            }
            if (!projectAlreadyHasViteTargets.preview) {
                (0, _generatorutils.addPreviewTarget)(tree, schema, serveTargetName);
            }
        }
    }
    if (projectType === 'library') {
        // update tsconfig.lib.json to include vite/client
        (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.lib.json'), (json)=>{
            if (!json.compilerOptions) {
                json.compilerOptions = {};
            }
            if (!json.compilerOptions.types) {
                json.compilerOptions.types = [];
            }
            if (!json.compilerOptions.types.includes('vite/client')) {
                return _extends._({}, json, {
                    compilerOptions: _extends._({}, json.compilerOptions, {
                        types: [
                            ...json.compilerOptions.types,
                            'vite/client'
                        ]
                    })
                });
            }
            return json;
        });
    }
    if (!schema.newProject) {
        // We are converting existing project to use Vite
        if (schema.uiFramework === 'react') {
            (0, _generatorutils.createOrEditViteConfig)(tree, {
                project: schema.project,
                includeLib: schema.includeLib,
                includeVitest: schema.includeVitest,
                inSourceTests: schema.inSourceTests,
                rollupOptionsExternal: [
                    "'react'",
                    "'react-dom'",
                    "'react/jsx-runtime'"
                ],
                imports: [
                    schema.compiler === 'swc' ? `import react from '@vitejs/plugin-react-swc'` : `import react from '@vitejs/plugin-react'`
                ],
                plugins: [
                    'react()'
                ]
            }, false, undefined);
        } else {
            (0, _generatorutils.createOrEditViteConfig)(tree, schema, false, projectAlreadyHasViteTargets);
        }
    }
    if (schema.includeVitest) {
        const vitestTask = await (0, _vitestgenerator.default)(tree, {
            project: schema.project,
            uiFramework: schema.uiFramework,
            inSourceTests: schema.inSourceTests,
            coverageProvider: 'v8',
            skipViteConfig: true,
            testTarget: testTargetName,
            skipFormat: true,
            addPlugin: schema.addPlugin
        });
        tasks.push(vitestTask);
    }
    if (!schema.skipFormat) {
        await (0, _devkit.formatFiles)(tree);
    }
    return (0, _devkit.runTasksInSerial)(...tasks);
}
const _default = viteConfigurationGenerator;

//# sourceMappingURL=configuration.js.map